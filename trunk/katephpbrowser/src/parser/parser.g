/*
 *   Copyright (C) 2006 by Thiago Silva                                    *
 *   thiago.silva@kdemal.net                                               *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
                                                                           */


header {
   #include "antlr/Token.hpp"
   #include "PHPAST.hpp"
   #include "PHPParserTokenTypes.hpp"
  using namespace antlr;
}

options {
  language="Cpp";  
}

class PHPParser extends Parser;
options {
  buildAST = true;
  ASTLabelType="RefPHPAST";
  importVocab=PHP;  // use vocab generated by lexer
  genHashLines=false;//no #line
}


{
	virtual void match(int t)
	{
		if ( DEBUG_PARSER )
		{
			traceIndent();
			ANTLR_USE_NAMESPACE(std)cout << "enter match(" << t << ") with LA(1)=" << LA(1)  
        << " (LT(1)) \"" << LT(1)->getText() << "\" at line " << LT(1)->getLine() << ANTLR_USE_NAMESPACE(std)endl;
		}
		if ( LA(1) != t )
		{
			if ( DEBUG_PARSER )
			{
				traceIndent();
				ANTLR_USE_NAMESPACE(std)cout << "token mismatch: " << LA(1) << "!=" << t << " (LT(1)) \"" 
          << LT(1)->getText() << "\" at line " << LT(1)->getLine() << ANTLR_USE_NAMESPACE(std)endl;
			}
			throw MismatchedTokenException(getTokenNames(), getNumTokens(), LT(1), t, false, getFilename());
		}
		else
		{
			// mark token as consumed -- fetch next token deferred until LA/LT
			consume();
		}
	}

	virtual void match(const BitSet& b)
	{
		if ( DEBUG_PARSER )
		{
			traceIndent();
			ANTLR_USE_NAMESPACE(std)cout << "enter match(" << "bitset" /*<< b.toString()*/
				<< ") with LA(1)=" << LA(1) 
        << " (LT(1)) \"" << LT(1)->getText() << "\" at line " << LT(1)->getLine() << ANTLR_USE_NAMESPACE(std)endl;
		}
		if ( !b.member(LA(1)) )
		{
			if ( DEBUG_PARSER )
			{
				traceIndent();
				ANTLR_USE_NAMESPACE(std)cout << "token mismatch: " << LA(1) << " not member of "
					<< "bitset" /*<< b.toString() << */
          << " (LT(1)) \"" << LT(1)->getText() << "\" at line " << LT(1)->getLine() << ANTLR_USE_NAMESPACE(std)endl;
			}
			throw MismatchedTokenException(getTokenNames(), getNumTokens(), LT(1), b, false, getFilename());
		}
		else
		{
			// mark token as consumed -- fetch next token deferred until LA/LT
			consume();
		}
	}
}

start!
  :  s:scopes EOF! {#start = #([T_PHP_MODULE, "php_module"],s);}
  ;

scopes
/* Continue until LA(1) != EOF */
  : ( options { generateAmbigWarnings=false; } : {LA(1) != 1}? scopes_ex)*
  ;

scopes_ex
  :  (T_START_PHP)=> php_scope
  |  other_scope
  ;

//Should be clearer....
other_scope
  :! ~(EOF)
  ;        


php_scope
  : T_START_PHP! (stuff)* T_END_PHP!
  ;

stuff
  :! (T_FUNCTION)=> f:function_decl {#stuff = #([T_FUNCTION,"function"], (f, [T_PUBLIC,"public"]));}
  |  (T_CLASS)=> T_CLASS^ class_decl
  |  (T_ABSTRACT)=> T_ABSTRACT! T_CLASS^ class_decl
  |  (T_INTERFACE)=> T_INTERFACE^ interface_decl //deal with interfaces just like classes
  |! ~(T_END_PHP)
  ;


class_decl
  : T_IDENTIFIER (ext)? T_OPEN_BRACKET! (class_member)*        T_CLOSE_BRACKET!
  ;

ext!
  : T_EXTENDS T_IDENTIFIER (T_IMPLEMENTS T_IDENTIFIER)?
  | T_IMPLEMENTS T_IDENTIFIER
  ;

interface_decl
  : T_IDENTIFIER T_OPEN_BRACKET! (interf_member)*        T_CLOSE_BRACKET!
  ;

interf_member
  :! a:access_modifier f:T_FUNCTION i:T_IDENTIFIER  params T_TERMINATOR {#interf_member = #(f, (i, a));}
  | const_attr
  ;

class_member
  : access_member
  | static_member
  | var_attr
  | const_attr
  |! m:function_decl! {#class_member = #([T_FUNCTION,"function"], (m, [T_PUBLIC,"public"]));}
  ;

/*
  function f() {}
  public function f() {}
  abstract public function f();
  abstract function f();
  public abstract function f();

  ---
  var $x;
  var $x = 2;
  var $x, $u = 2;
  public $x;
  public $x = 3;
  public static $x;
  public static $x = 3;
*/
access_member!
  : a:access_modifier (s:T_STATIC)? 
      (
          //the negated (T_VARIABLE|T_IDENTIFIER) must be here to fix nondeterminism
          v:vars (~(T_TERMINATOR|T_VARIABLE|T_IDENTIFIER))* T_TERMINATOR! {#access_member = #([T_VAR,"var"], ([T_VARIABLES,"vars:"],v, ([T_MODIFIERS,"mods"],a, s)));}
        | (T_ABSTRACT!)? m:function_decl {#access_member = #([T_FUNCTION,"function"], (m, a));}
      )
  | T_ABSTRACT (aa:access_modifier)? mm:function_decl {#access_member = #([T_FUNCTION,"function"], (mm, aa));}
  ;

static_member!
  : T_STATIC 
      (   v:vars  T_TERMINATOR! {#static_member = #([T_VAR, "var"], ([T_VARIABLES,"vars:"], v, ([T_MODIFIERS,"mods"],[T_PUBLIC,"public"], [T_STATIC,"static"])));}
        | m:function_decl  {#static_member = #([T_FUNCTION,"function"], (m, [T_PUBLIC,"public"], [T_STATIC,"static"]));}
      )
  ;

access_modifier
  : ( T_PUBLIC | T_PROTECTED | T_PRIVATE )
  ;

// access_member_ex
//   :  (T_VARIABLE)+
//   | m:function_decl
//   ;

var_attr!
  : t:T_VAR v:vars T_TERMINATOR!
  {#var_attr = #([T_VAR, "var"], ([T_VARIABLES,"vars:"],v, ([T_MODIFIERS, "mods:"], [T_PUBLIC,"public"])));}
  ;

// T_IDENTIFIER must be here for "$somev = null"
vars
  : (T_VARIABLE | T_IDENTIFIER!)+
  ;

const_attr!
  : c:T_CONST i:identifiers T_TERMINATOR
  {#const_attr = #(c, i);}
  ;

identifiers
  : (T_IDENTIFIER)+
  ;

function_decl
  : T_FUNCTION! T_IDENTIFIER  params function_decl_ex
  ;

function_decl_ex
  : T_OPEN_BRACKET!

    (deal_function_body)*

    T_CLOSE_BRACKET!
  | T_TERMINATOR!
  ;

params!
  : T_OPEN_PAR (deal_par)? T_CLOSE_PAR
  ;

deal_par!
  : ( ~(T_OPEN_PAR | T_CLOSE_PAR ) //ignores all parameters that don't use parentesis
      | T_OPEN_PAR (deal_par)? T_CLOSE_PAR //deal with parameters such as func($a = array(..))
    )+
  ;

deal_function_body!
  : ~(T_CLOSE_BRACKET | T_OPEN_BRACKET)
  | T_OPEN_BRACKET (deal_function_body)* T_CLOSE_BRACKET
  ;

