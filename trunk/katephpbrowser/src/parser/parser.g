/*
 *   Copyright (C) 2006 by Thiago Silva                                    *
 *   thiago.silva@kdemal.net                                               *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
                                                                           */


header {
   #include "antlr/Token.hpp"
  using namespace antlr;
}

options {
  language="Cpp";  
}

class PHPParser extends Parser;
options {
 buildAST = true;
//   ASTLabelType="RefPortugolAST";
  importVocab=PHP;  // use vocab generated by lexer
  genHashLines=false;//no #line
}

start!
  :  s:scopes EOF! {#start = #([T_PHP_MODULE, "php_module"],s);}
  ;

scopes
  : (php_scope)*
  ;
php_scope
  : T_START_PHP! (stuff)* T_END_PHP!
  ;

stuff
  :! (T_FUNCTION)=> f:function_decl {#stuff = #([T_FUNCTION,"function"], (f, [T_PUBLIC,"public"]));}
  |  (T_CLASS)=> T_CLASS^ class_decl
  |  (T_INTERFACE)=> T_INTERFACE^ interface_decl //deal with interfaces just like classes
  |! ~(T_END_PHP)
  ;


class_decl
  : T_IDENTIFIER T_OPEN_BRACKET! (class_member)*        T_CLOSE_BRACKET!
  ;

interface_decl
  : T_IDENTIFIER T_OPEN_BRACKET! (interf_member)*        T_CLOSE_BRACKET!
  ;

interf_member
  :! a:access_modifier f:T_FUNCTION i:T_IDENTIFIER  params {#interf_member = #(f, (i, a));}
  | const_attr
  ;

class_member
  : access_member
  | static_member
  | var_attr
  | const_attr
  |! m:function_decl! {#class_member = #([T_FUNCTION,"function"], (m, [T_PUBLIC,"public"]));}
  ;

access_member!
  : a:access_modifier (s:T_STATIC)? 
      (
          v:vars {#access_member = #([T_VAR,"var"], ([T_VARIABLES,"vars:"],v, ([T_MODIFIERS,"mods"],a, s)));}
        | m:function_decl {#access_member = #([T_FUNCTION,"function"], (m, a));}
      )   
  ;

static_member!
  : T_STATIC 
      (   v:vars  {#static_member = #([T_VAR, "var"], ([T_VARIABLES,"vars:"], v, ([T_MODIFIERS,"mods"],[T_PUBLIC,"public"], [T_STATIC,"static"])));}
        | m:function_decl  {#static_member = #([T_FUNCTION,"function"], (m, [T_PUBLIC,"public"], [T_STATIC,"static"]));}
      )
  ;

access_modifier
  : ( T_PUBLIC | T_PROTECTED | T_PRIVATE )
  ;

// access_member_ex
//   :  (T_VARIABLE)+
//   | m:function_decl
//   ;

var_attr!
  : t:T_VAR v:vars
  {#var_attr = #([T_VAR, "var"], ([T_VARIABLES,"vars:"],v, ([T_MODIFIERS, "mods:"], [T_PUBLIC,"public"])));}
  ;

vars
  : (T_VARIABLE)+
  ;

const_attr
  : T_CONST^ (T_IDENTIFIER)+ 
  ;

interf_funcs
  : T_FUNCTION^ T_IDENTIFIER  params
  ;

function_decl
  : T_FUNCTION! T_IDENTIFIER  params
    T_OPEN_BRACKET!

    (deal_function_body)*

    T_CLOSE_BRACKET!
  ;

params!
  : T_OPEN_PAR (deal_par)? T_CLOSE_PAR
  ;

deal_par
  : ( ~(T_OPEN_PAR | T_CLOSE_PAR ) //ignores all parameters that don't use parentesis
      | T_OPEN_PAR (deal_par)? T_CLOSE_PAR //deal with parameters such as func($a = array(..))
    )+
  ;

deal_function_body!
  : ~(T_CLOSE_BRACKET | T_OPEN_BRACKET)
  | T_OPEN_BRACKET (deal_function_body)* T_CLOSE_BRACKET
  ;

