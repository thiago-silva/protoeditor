/*
 *   Copyright (C) 2006 by Thiago Silva                                    *
 *   thiago.silva@kdemal.net                                               *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, write to the                         *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
                                                                           */ 

header {
  #include <qvaluelist.h>
  #include "browsernode.h"
}

options {
  language="Cpp";
}

class PHPNodeWalker extends TreeParser;
options {
  importVocab=PHP;  // use vocab generated by lexer
  genHashLines=false;//no #line
}

{
  private:
}

start returns [QValueList<BrowserNode*> list]
{BrowserNode* c;}
  :  #(T_PHP_MODULE 
        (
          c=root_stuff {list.append(c);}
        )*
      )
  ;

root_stuff returns [BrowserNode* node]
  : #(T_CLASS t:T_IDENTIFIER 

      {        
        node = new BrowserNode();
        node->setName(t->getText().c_str());
        node->setType(BrowserNode::ClassType);
      }

      (members[node])*
    )

  | #(T_INTERFACE i:T_IDENTIFIER 

      {
        node = new BrowserNode();
        node->setName(i->getText().c_str());
        node->setType(BrowserNode::InterfaceType);
      }

      (members[node])*
    )
  | node=function
  ;

members[BrowserNode* parent]
{
  BrowserNode* tmp;
  BrowserNode* f;
}
  : #(T_VAR var_list[parent])
  | #(T_CONST 
        (
          t:T_IDENTIFIER
          {
            tmp = new BrowserNode();
            tmp->setName(t->getText().c_str());
            tmp->setType(BrowserNode::ConstType);
            parent->addChild(tmp);
          }
        )+
      )
  | f=function {parent->addChild(f);}
  ;

var_list[BrowserNode* parent]
{
  QValueList<BrowserNode*> list;
  BrowserNode* var;
  int a;
  bool isStatic = false;
}

  : #(T_VARIABLES
      (
        t:T_VARIABLE
        {
          var = new BrowserNode();
          var->setName(t->getText().c_str());
          var->setType(BrowserNode::AttributeType);
          list.append(var);
        }
      )+ 

      #(T_MODIFIERS a=access (T_STATIC {isStatic = true;} )? )
    )

    {
      for(QValueList<BrowserNode*>::iterator it = list.begin(); it != list.end(); ++it)
      {
        (*it)->setVisibility(a);
        (*it)->setStatic(isStatic);
        parent->addChild(*it);
      }
    }
  ;

access returns [int ret]
  : T_PUBLIC    {ret = BrowserNode::Public;}
  | T_PROTECTED {ret = BrowserNode::Protected;}
  | T_PRIVATE   {ret = BrowserNode::Private;}
  ;

function returns [BrowserNode* node]
{
  bool isStatic = false;
  int a;
}
  : #(T_FUNCTION #(t:T_IDENTIFIER a=access (T_STATIC {isStatic = true;})? ) )
    {
      node = new BrowserNode();
      node->setName(t->getText().c_str());
      node->setVisibility(a);
      node->setStatic(isStatic);
    }
  ;
